input {
  file {
    path => [
      # "C:/dfir_copy/client_data/*/output/parsed/*/*/*.csv",
      "C:/dfir_copy/client_data/*/output/parsed/*/*/*.json"
      # "C:/dfir_copy/client_data/*/output/network_logs/fortigate/logs/*/*",
      # "C:/dfir_copy/client_data/*/iis_logs/*/*.log"
    ]
    codec => json 

    mode => "read"
    start_position => "beginning"
    sincedb_path => "NUL"

    file_completed_action => "log"
    file_completed_log_path => "C:/dfir_copy/processed_all.log"

    file_chunk_size  => 524288
    file_chunk_count => 32

    
  }


  file {
    path => [
      "C:/dfir_copy/client_data/*/output/parsed/*/*/*.csv",
      # "C:/dfir_copy/client_data/*/output/parsed/*/*/*.json",
      "C:/dfir_copy/client_data/*/output/network_logs/fortigate/logs/*/*",
      "C:/dfir_copy/client_data/*/iis_logs/*/*.log"
    ]

    mode => "read"
    start_position => "beginning"
    sincedb_path => "NUL"

    file_completed_action => "log"
    file_completed_log_path => "C:/dfir_copy/processed_all.log"

    file_chunk_size  => 524288
    file_chunk_count => 32

    
    codec => plain { charset => "UTF-8" }
  }




}






filter {

  # Normalize path
  mutate { add_field => { "filename" => "%{[log][file][path]}" } }
  mutate { lowercase => ["filename"] }

  # -------------------------------
  # CLIENT NAME FROM PATH
  # -------------------------------
  # grok { match => { "filename" => "client_data/%{DATA:client}/output/parsed/_%{DATA:skadi_name}_skadi" } }
  grok { match => { "filename" => "client_data/%{DATA:client}/" } }
  mutate { lowercase => ["client"] }
  # mutate { lowercase => ["skadi_name"] }

  if [filename] =~ "amcache" {
    mutate { add_field => { "artifact_type" => ["amcache"] } }



    # -----------------------------------
    # Detect artifact type from filename
    # -----------------------------------
    if [filename] =~ "devicecontainers.csv" {

      csv {
        separator => ","
        skip_header => true
        columns => [
          "KeyName","KeyLastWriteTimestamp","Categories","DiscoveryMethod",
          "FriendlyName","Icon","IsActive","IsConnected","IsMachineContainer",
          "IsNetworked","IsPaired","Manufacturer","ModelId","ModelName",
          "ModelNumber","PrimaryCategory","State"
        ]
      }

    } else if [filename] =~ "devicepnps.csv" {

      csv {
        separator => ","
        skip_header => true
        columns => [
          "KeyName","KeyLastWriteTimestamp","BusReportedDescription","Class",
          "ClassGuid","Compid","ContainerId","Description","DriverId",
          "DriverPackageStrongName","DriverName","DriverVerDate",
          "DriverVerVersion","Enumerator","HWID","Inf","InstallState",
          "Manufacturer","MatchingId","Model","ParentId","ProblemCode",
          "Provider","Service","Stackid"
        ]
      }

    } else if [filename] =~ "drivebinaries.csv" {

      csv {
        separator => ","
        skip_header => true
        columns => [
          "KeyName","KeyLastWriteTimestamp","DriverTimeStamp",
          "DriverLastWriteTime","DriverName","DriverInBox",
          "DriverIsKernelMode","DriverSigned","DriverCheckSum",
          "DriverCompany","DriverId","DriverPackageStrongName",
          "DriverType","DriverVersion","ImageSize","Inf",
          "Product","ProductVersion","Service","WdfVersion"
        ]
      }

    } else if [filename] =~ "driverpackages.csv" {

      csv {
        separator => ","
        skip_header => true
        columns => [
          "KeyName","KeyLastWriteTimestamp","Date","Class","Directory",
          "DriverInBox","Hwids","Inf","Provider","SubmissionId",
          "SYSFILE","Version"
        ]
      }

    } else if [filename] =~ "shortcuts.csv" {

      csv {
        separator => ","
        skip_header => true
        columns => [
          "KeyName","LnkName","KeyLastWriteTimestamp"
        ]
      }

    } else if [filename] =~ "unassociatedfileentries.csv" {

      csv {
        separator => ","
        skip_header => true
        columns => [
          "ApplicationName","ProgramId","FileKeyLastWriteTimestamp",
          "SHA1","IsOsComponent","FullPath","Name","FileExtension",
          "LinkDate","ProductName","Size","Version","ProductVersion",
          "LongPathHash","BinaryType","IsPeFile","BinFileVersion",
          "BinProductVersion","Usn","Language","Description"
        ]
      }

    }
    date {
      match => ["KeyLastWriteTimestamp", "yyyy-MM-dd HH:mm:ss"]
      target => "@timestamp"
    }


  }




  if [filename] =~ "eventlogs" {
    mutate { add_field => { "artifact_type" => ["evtx"] } }


    ############################
    # Drop empty lines
    ############################
    if [message] =~ /^\s*$/ {
      drop {}
    }

    ############################
    # Parse outer EVTX JSON
    ############################
    json {
      source => "message"
    }


  }

  if [filename] =~ "lnk" {
    mutate { add_field => { "artifact_type" => ["lnk"] } }


    ############################
    # Drop empty lines
    ############################
    if [message] =~ /^\s*$/ {
      drop {}
    }

    ############################
    # Parse outer EVTX JSON
    ############################
    json {
      source => "message"
    }


  }

  if [filename] =~ "jumplist" {
    mutate { add_field => { "artifact_type" => ["jumplist"] } }


    ############################
    # Drop empty lines
    ############################
    if [message] =~ /^\s*$/ {
      drop {}
    }

    ############################
    # Parse outer EVTX JSON
    ############################
    json {
      source => "message"
    }


  }





  if [filename] =~ "mft" {
    mutate { add_field => { "artifact_type" => ["mft"] } }


    ############################
    # Drop empty lines
    ############################
    if [message] =~ /^\s*$/ {
      drop {}
    }

    ############################
    # Parse outer EVTX JSON
    ############################
    json {
      source => "message"
    }


  }



  if [filename] =~ "prefetch" {
    mutate { add_field => { "artifact_type" => ["prefetch"] } }


    ############################
    # Drop empty lines
    ############################
    if [message] =~ /^\s*$/ {
      drop {}
    }

    ############################
    # Parse outer EVTX JSON
    ############################
    json {
      source => "message"
    }


  }








  if [filename] =~ "shimcache" {
    mutate { add_field => { "artifact_type" => ["shimcache"] } }

      csv {
        separator => ","
        skip_header => true
        columns => [
          "ControlSet",
          "CacheEntryPosition",
          "Path",
          "LastModifiedTimeUTC",
          "Executed",
          "Duplicate",
          "SourceFile"
        ]
      }


      # Native Shimcache timestamp format
      date {
        match => [
          "LastModifiedTimeUTC",
          "yyyy-MM-dd HH:mm:ss",
          "ISO8601"
        ]
        timezone => "UTC"
        target => "last_modified_time"
      }


  }


  if [filename] =~ "srum" {
    mutate { add_field => { "artifact_type" => ["srum"] } }

    ####################################################
    # ECS NORMALIZATION
    ####################################################
    mutate {
      copy => {
        "[event][original]" => "message"
        "[log][file][path]" => "path"
      }

    }

    ####################################################
    # DROP EMPTY LINES
    ####################################################
    if [message] =~ /^\s*$/ {
      drop { }
    }


    ####################################################
    # AppResourceUseInfo
    ####################################################
    if [path] =~ /_AppResourceUseInfo_Output\.csv$/ {
      csv {
        source => "message"
        columns => [
          "Id","Timestamp","ExeInfo","ExeInfoDescription","ExeTimestamp",
          "SidType","Sid","UserName","UserId","AppId",
          "BackgroundBytesRead","BackgroundBytesWritten","BackgroundContextSwitches",
          "BackgroundCycleTime","BackgroundNumberOfFlushes",
          "BackgroundNumReadOperations","BackgroundNumWriteOperations",
          "FaceTime",
          "ForegroundBytesRead","ForegroundBytesWritten","ForegroundContextSwitches",
          "ForegroundCycleTime","ForegroundNumberOfFlushes",
          "ForegroundNumReadOperations","ForegroundNumWriteOperations"
        ]
      }
      mutate { add_field => { "srum_table" => "AppResourceUseInfo" } }
    }

    ####################################################
    # AppTimelineProvider
    ####################################################
    else if [path] =~ /_AppTimelineProvider_Output\.csv$/ {
      csv {
        source => "message"
        columns => [
          "Id","Timestamp","ExeInfo","ExeInfoDescription","ExeTimestamp",
          "SidType","Sid","UserName","UserId","AppId",
          "EndTime","DurationMs"
        ]
      }
      mutate { add_field => { "srum_table" => "AppTimelineProvider" } }
    }

    ####################################################
    # EnergyUsage
    ####################################################
    else if [path] =~ /_EnergyUsage_Output\.csv$/ {
      csv {
        source => "message"
        columns => [
          "Id","Timestamp","ExeInfo","ExeInfoDescription","ExeTimestamp",
          "SidType","Sid","UserName","UserId","AppId",
          "IsLt","ConfigurationHash","EventTimestamp","StateTransition",
          "ChargeLevel","CycleCount","DesignedCapacity","FullChargedCapacity",
          "ActiveAcTime","ActiveDcTime","ActiveDischargeTime","ActiveEnergy",
          "CsAcTime","CsDcTime","CsDischargeTime","CsEnergy"
        ]
      }
      mutate { add_field => { "srum_table" => "EnergyUsage" } }
    }

    ####################################################
    # NetworkConnections
    ####################################################
    else if [path] =~ /_NetworkConnections_Output\.csv$/ {
      csv {
        source => "message"
        columns => [
          "Id","Timestamp","ExeInfo","ExeInfoDescription","ExeTimestamp",
          "SidType","Sid","UserName","UserId","AppId",
          "ConnectedTime","ConnectStartTime",
          "InterfaceLuid","InterfaceType",
          "L2ProfileFlags","L2ProfileId","ProfileName"
        ]
      }
      mutate { add_field => { "srum_table" => "NetworkConnections" } }
    }

    ####################################################
    # NetworkUsages
    ####################################################
    else if [path] =~ /_NetworkUsages_Output\.csv$/ {
      csv {
        source => "message"
        columns => [
          "Id","Timestamp","ExeInfo","ExeInfoDescription","ExeTimestamp",
          "SidType","Sid","UserName","UserId","AppId",
          "BytesReceived","BytesSent",
          "InterfaceLuid","InterfaceType",
          "L2ProfileFlags","L2ProfileId","ProfileName"
        ]
      }
      mutate { add_field => { "srum_table" => "NetworkUsages" } }
    }

    ####################################################
    # PushNotifications
    ####################################################
    else if [path] =~ /_PushNotifications_Output\.csv$/ {
      csv {
        source => "message"
        columns => [
          "Id","Timestamp","ExeInfo","ExeInfoDescription","ExeTimestamp",
          "SidType","Sid","UserName","UserId","AppId",
          "NetworkType","NotificationType","PayloadSize"
        ]
      }
      mutate { add_field => { "srum_table" => "PushNotifications" } }
    }

    ####################################################
    # vfuprov
    ####################################################
    else if [path] =~ /_vfuprov_Output\.csv$/ {
      csv {
        source => "message"
        columns => [
          "Id","Timestamp","UserId","AppId",
          "ExeInfo","ExeInfoDescription","ExeTimestamp",
          "SidType","Sid","UserName",
          "StartTime","EndTime","Flags","Duration"
        ]
      }
      mutate { add_field => { "srum_table" => "vfuprov" } }
    }

  }



  if [filename] =~ "fortigate" {
    mutate { add_field => { "artifact_type" => ["fortigate"] } }

    # -------------------------------
    # TIMESTAMP NORMALIZATION
    # -------------------------------
    if [date] and [time] {
      date {
        match => ["date time", "yyyy-MM-dd HH:mm:ss"]
        target => "@timestamp"
        timezone => "Asia/Kolkata"
      }
    } else if [eventtime] {
      # FortiGate eventtime is nanoseconds
      ruby {
        code => '
          event.set("@timestamp",
            Time.at(event.get("eventtime") / 1000000000.0)
          )
        '
      }
    }

    # -------------------------------
    # TYPE NORMALIZATION (OPTIONAL)
    # -------------------------------
    mutate {
      lowercase => ["type", "subtype", "action"]
    }

    # -------------------------------
    # CLEANUP
    # -------------------------------
    mutate {
      remove_field => [
        "message",
        "host",
        "agent",
        "ecs",
        "@version",
        "tags"
      ]
    }



  }



  if [filename] =~ "iis" {
    mutate { add_field => { "artifact_type" => ["iis_logs"] } }
    #################################
    # Drop IIS W3C headers
    #################################
    if [message] =~ "^#" {
      drop { }
    }

    #################################
    # IIS W3C GROK (SAFE & EXACT)
    #################################
    grok {
      match => {
        "message" => [
          "%{YEAR:log_year}-%{MONTHNUM:log_month}-%{MONTHDAY:log_day} %{TIME:log_time} %{IPORHOST:server.ip} %{NOTSPACE:http.request.method} %{NOTSPACE:iis.uri_stem} %{NOTSPACE:iis.uri_query} %{INT:destination.port} %{DATA:user.name} %{IPORHOST:source.ip} %{DATA:user_agent.original} %{DATA:http.referer} %{INT:http.response.status_code} %{INT:iis.substatus} %{INT:win32.status} %{INT:event.duration}"
        ]
      }
    }

    #################################
    # Build log_date
    #################################
    mutate {
      add_field => {
        "log_date" => "%{log_year}-%{log_month}-%{log_day}"
      }
    }



    #################################
    # Normalize IIS "-" values
    #################################
    if [iis][uri_query] == "-" {
      mutate { replace => { "[iis][uri_query]" => "" } }
    }

    if [user][name] == "-" {
      mutate { replace => { "[user][name]" => "" } }
    }

    if [http][referer] == "-" {
      mutate { replace => { "[http][referer]" => "" } }
    }

    #################################
    # ECS URL mapping
    #################################
    mutate {
      rename => {
        "[iis][uri_stem]"  => "[url][path]"
        "[iis][uri_query]" => "[url][query]"
      }
    }

    #################################
    # IIS time-taken (µs → ns)
    #################################
    mutate {
      convert => { "event.duration" => "integer" }
    }

    ruby {
      code => '
        v = event.get("event.duration")
        event.set("event.duration", v * 1000000) if v
      '
    }

    #################################
    # User-Agent parsing
    #################################
    useragent {
      source => "user_agent.original"
      target => "user_agent"
    }

    #################################
    # Cleanup
    #################################
    mutate {
      remove_field => [
        "message",
        "log_year",
        "log_month",
        "log_day"
      ]
    }

  }


}



output {
  elasticsearch {
    hosts => ["https://65.2.125.139:9200"]
    user  => "elastic"
    password => "wsQcbfozMJF2BEnljEAq"
    ssl_enabled => true
    ssl_verification_mode => "none"
    index => "dfir-%{client}-%{artifact_type}-all-in-one"
  }
}
